# Copyright 2009 Michael Murr
#
# This file is part of LibForensics.
#
# LibForensics is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# LibForensics is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with LibForensics.  If not, see <http://www.gnu.org/licenses/>.

"""
Bit-oriented data types.

.. moduleauthor:: Michael Murr (mmurr@codeforensics.net)
"""

from collections import OrderedDict
from lf.datatype.base import DataType, Basic
from lf.datatype.decode import Decoder

__docformat__ = "restructuredtext en"
__all__ = [
    "bit", "bits", "BitType", "BitType8", "BitTypeU8", "BitType16",
    "BitTypeU16", "BitType32", "BitTypeU32", "BitType64", "BitTypeU64"
]

class bits(DataType):
    """
    Represents one or more bits.

    .. attribute:: _size_

        The number of bits in the data type.
    """

    def __init__(self, size=1):
        """
        Initializes a bits object.

        :parameters:
            size
                The number of bits in the data type.
        """

        super(bits, self).__init__()
        self._size_ = size
    # end def __init__
# end class bits

class bit(bits):
    """Represents a single bit"""

    _size_ = 1
# end class bit

class MetaBitType(type):
    """Metaclass to setup up bits and decoder in BitType classes"""

    @classmethod
    def __prepare__(metacls, name, bases):
        """Makes the class's dict an OrderedDict"""

        return OrderedDict()
    # end def __prepare__

    def __new__(cls, name, bases, clsdict):
        """Creates the _fields_ variable (if necessary)"""

        new_cls = type.__new__(cls, name, bases, clsdict)
        new_clsdict = new_cls.__dict__

        fields = new_clsdict.get("_fields_")
        size = new_clsdict.get("_size_")
        mro = new_cls.__mro__

        if fields is None:
            fields = list()

            klsdicts = [klass.__dict__ for klass in mro]
            klsdicts[0] = clsdict

            for klsdict in klsdicts:
                try:
                    _fields_ = iter(klsdict.get("_fields_"))
                except TypeError:
                    _fields_ = iter(klsdict.items())
                # end if

                klass_fields = list()
                for (fname, bits_obj) in _fields_:
                    if fname.startswith("_") or (fname == "bits_pad_"):
                        continue
                    else:
                        klass_fields.append((fname, bits_obj))
                    # end if
                # end for

                klass_fields.extend(fields)
                fields = klass_fields
            # end for

            new_cls._fields_ = fields
        # end if

        if size is None:
            for klass in mro:
                try:
                    size = klass.__dict__.get("_size_")

                    if size is not None:
                        break
                    # end if
                except AttributeError:
                    pass
                # end try
            else:
                msg = "BitType classes must have _size_ attribute"
                raise AttributeError(msg)
            # end for
        # end if

        max_bit_size = size * 8
        total_bit_size = sum([field[1]._size_ for field in fields])
        if total_bit_size < max_bit_size:
            bits_name = "bits_pad_"
            bits_obj = bits(max_bit_size - total_bit_size)

            new_cls.bits_pad_ = bits_obj
            fields.append((bits_name, bits_obj))
        # end if

        return new_cls
    # end def __new__

    def __init__(cls, name, bases, clsdict):
        """Initializes a BitType.__class__ object"""

        fields = cls._fields_
        decoder = clsdict.get("_decoder_")

        if decoder is None:
            bits_objs = [item[1] for item in fields]
            cls._decoder_ = Decoder(bits_objs)
        # end if

        super(MetaBitType, cls).__init__(name, bases, clsdict)
    # end def __init__
# end class MetaBitType

class BitType(Basic, metaclass=MetaBitType):
    """
    A wrapper around bits, used to ensure an integral size

    .. attribute:: _size_

        The number of bytes in the BitType.

    .. attribute:: _decoder_

        A Decoder that can extract the individual bits. If this value is None,
        it is auto-genearted by the metaclass.

    .. attribute:: _fields_

        A list of (name, bits) pairs of the bit fields.  If this value is None,
        it is auto-generated by the metaclass.
    """

    _fields_ = None
    _decoder_ = None
    _size_ = 0

    def __init__(self):
        """
        Initializes a BitType object.

        :raises:
            OverflowError
                If the cumulative size of bit fields is too big for the
                container.
        """

        super(BitType, self).__init__()
        bit_size = 0

        for (name, bits_obj) in self._fields_:
            bit_size += bits_obj._size_
        # end for

        if bit_size > (self._size_ * 8):
            raise OverflowError("Too many bits")
        # end if
    # end def __init__
# end class BitType

class BitType8(BitType):
    """A bit type represented by a signed 8-bit integer"""

    _size_ = 1
    _format_ = "b"
# end class BitType8

class BitTypeU8(BitType):
    """A bit type represented by an unsigned 8-bit integer"""

    _size_ = 1
    _format_ = "B"
# end class BitTypeU8

class BitType16(BitType):
    """A bit type represented by a signed 16-bit integer"""

    _size_ = 2
    _format_ = "h"
# end class bits16

class BitTypeU16(BitType):
    """A bit type represented by an unsigned 16-bit integer"""

    _size_ = 2
    _format_ = "H"
# end class BitTypeU16

class BitType32(BitType):
    """A bit type represented by a signed 32-bit integer"""

    _size_ = 4
    _format_ = "i"
# end class BitType32

class BitTypeU32(BitType):
    """A bit type represented by an unsigned 32-bit integer"""

    _size_ = 4
    _format_ = "I"
# end class BitTypeU32

class BitType64(BitType):
    """A bit type represented by a signed 64-bit integer"""

    _size_ = 8
    _format_ = "q"
# end class BitType64

class BitTypeU64(BitType):
    """A bit type represented by an unsigned 64-bit integer"""

    _size_ = 8
    _format_ = "Q"
# end class BitTypeU64
